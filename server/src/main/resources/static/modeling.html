<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SysML v2 å»ºæ¨¡å·¥ä½œå° - Sirius Web</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #f5f5f5;
        }
        
        /* é¡¶éƒ¨å·¥å…·æ  */
        .toolbar {
            background: #2c3e50;
            color: white;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .toolbar h1 {
            font-size: 18px;
            margin-right: auto;
        }
        
        .toolbar button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .toolbar button:hover {
            background: #2980b9;
        }
        
        /* ä¸»å®¹å™¨ */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        /* å·¦ä¾§é¢æ¿ - ç»„ä»¶åº“ */
        .palette {
            width: 250px;
            background: white;
            border-right: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
        }
        
        .palette h3 {
            font-size: 14px;
            color: #666;
            margin-bottom: 15px;
            text-transform: uppercase;
        }
        
        .palette-item {
            background: #ecf0f1;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: move;
            transition: all 0.3s;
            text-align: center;
        }
        
        .palette-item:hover {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }
        
        .palette-item.requirement {
            border-color: #e74c3c;
        }
        
        .palette-item.block {
            border-color: #3498db;
        }
        
        .palette-item.interface {
            border-color: #f39c12;
        }
        
        .palette-item.constraint {
            border-color: #9b59b6;
        }
        
        /* ä¸­é—´ç”»å¸ƒ */
        .canvas-container {
            flex: 1;
            position: relative;
            background: white;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
        }
        
        /* å³ä¾§å±æ€§é¢æ¿ */
        .properties {
            width: 300px;
            background: white;
            border-left: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
        }
        
        .properties h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .property-group {
            margin-bottom: 20px;
        }
        
        .property-group label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .property-group input,
        .property-group select,
        .property-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .property-group textarea {
            min-height: 80px;
            resize: vertical;
        }
        
        /* SVGå…ƒç´ æ ·å¼ */
        .sysml-element {
            cursor: move;
        }
        
        .sysml-element.selected {
            filter: drop-shadow(0 0 3px #3498db);
        }
        
        .connection-line {
            stroke: #34495e;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }
        
        .connection-line.derive {
            stroke: #3498db;
            stroke-dasharray: 5,5;
        }
        
        .connection-line.refine {
            stroke: #e74c3c;
        }
        
        .connection-line.satisfy {
            stroke: #27ae60;
        }
        
        /* çŠ¶æ€æ  */
        .statusbar {
            background: #ecf0f1;
            padding: 5px 20px;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <h1>ğŸš€ SysML v2 å»ºæ¨¡å·¥ä½œå°</h1>
        <button onclick="saveModel()">ğŸ’¾ ä¿å­˜</button>
        <button onclick="loadModel()">ğŸ“‚ åŠ è½½</button>
        <button onclick="exportSVG()">ğŸ“· å¯¼å‡ºSVG</button>
        <button onclick="clearCanvas()">ğŸ—‘ï¸ æ¸…ç©º</button>
        <button onclick="autoLayout()">ğŸ“ è‡ªåŠ¨å¸ƒå±€</button>
    </div>
    
    <div class="main-container">
        <!-- å·¦ä¾§ç»„ä»¶é¢æ¿ -->
        <div class="palette">
            <h3>éœ€æ±‚å…ƒç´ </h3>
            <div class="palette-item requirement" draggable="true" data-type="requirement">
                ğŸ“‹ éœ€æ±‚ (Requirement)
            </div>
            
            <h3>ç»“æ„å…ƒç´ </h3>
            <div class="palette-item block" draggable="true" data-type="block">
                ğŸ“¦ å— (Block)
            </div>
            <div class="palette-item interface" draggable="true" data-type="interface">
                ğŸ”Œ æ¥å£ (Interface)
            </div>
            
            <h3>çº¦æŸå…ƒç´ </h3>
            <div class="palette-item constraint" draggable="true" data-type="constraint">
                âš–ï¸ çº¦æŸ (Constraint)
            </div>
            
            <h3>å…³ç³»</h3>
            <div class="palette-item" onclick="setConnectionMode('derive')">
                â†˜ï¸ æ´¾ç”Ÿ (Derive)
            </div>
            <div class="palette-item" onclick="setConnectionMode('refine')">
                ğŸ”„ ç»†åŒ– (Refine)
            </div>
            <div class="palette-item" onclick="setConnectionMode('satisfy')">
                âœ… æ»¡è¶³ (Satisfy)
            </div>
        </div>
        
        <!-- ä¸­é—´ç”»å¸ƒ -->
        <div class="canvas-container" 
             ondrop="handleDrop(event)" 
             ondragover="handleDragOver(event)">
            <svg id="canvas" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="10" 
                            refX="9" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" fill="#34495e" />
                    </marker>
                </defs>
                <g id="connections"></g>
                <g id="elements"></g>
            </svg>
        </div>
        
        <!-- å³ä¾§å±æ€§é¢æ¿ -->
        <div class="properties">
            <h3>å±æ€§</h3>
            <div id="property-content">
                <p style="color: #999;">é€‰æ‹©ä¸€ä¸ªå…ƒç´ æŸ¥çœ‹å±æ€§</p>
            </div>
        </div>
    </div>
    
    <div class="statusbar">
        <span id="status">å°±ç»ª</span> | 
        <span id="element-count">å…ƒç´ : 0</span> | 
        <span id="connection-count">è¿æ¥: 0</span>
    </div>
    
    <script>
        let elements = [];
        let connections = [];
        let selectedElement = null;
        let connectionMode = null;
        let connectionStart = null;
        let nextId = 1;
        
        // æ‹–æ‹½å¤„ç†
        document.querySelectorAll('.palette-item[draggable="true"]').forEach(item => {
            item.addEventListener('dragstart', handleDragStart);
        });
        
        function handleDragStart(e) {
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('elementType', e.target.dataset.type);
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }
        
        function handleDrop(e) {
            e.preventDefault();
            const type = e.dataTransfer.getData('elementType');
            const rect = document.getElementById('canvas').getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            createSysMLElement(type, x, y);
        }
        
        // åˆ›å»ºSysMLå…ƒç´ 
        function createSysMLElement(type, x, y) {
            const id = `element-${nextId++}`;
            const element = {
                id: id,
                type: type,
                x: x,
                y: y,
                width: 150,
                height: 80,
                name: `${type.charAt(0).toUpperCase()}${type.slice(1)}_${nextId}`,
                properties: {}
            };
            
            elements.push(element);
            drawElement(element);
            updateStatus();
            
            // ä¿å­˜åˆ°åç«¯
            saveElementToBackend(element);
        }
        
        // ç»˜åˆ¶å…ƒç´ 
        function drawElement(element) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('id', element.id);
            g.setAttribute('class', 'sysml-element');
            g.setAttribute('transform', `translate(${element.x}, ${element.y})`);
            
            // çŸ©å½¢èƒŒæ™¯
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', element.width);
            rect.setAttribute('height', element.height);
            rect.setAttribute('rx', '5');
            rect.setAttribute('fill', getElementColor(element.type));
            rect.setAttribute('stroke', '#333');
            rect.setAttribute('stroke-width', '2');
            
            // æ–‡æœ¬æ ‡ç­¾
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', element.width / 2);
            text.setAttribute('y', element.height / 2);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', 'white');
            text.setAttribute('font-size', '14');
            text.textContent = element.name;
            
            g.appendChild(rect);
            g.appendChild(text);
            
            // æ·»åŠ äº¤äº’
            g.addEventListener('mousedown', startDrag);
            g.addEventListener('click', selectElement);
            
            document.getElementById('elements').appendChild(g);
        }
        
        // è·å–å…ƒç´ é¢œè‰²
        function getElementColor(type) {
            const colors = {
                requirement: '#e74c3c',
                block: '#3498db',
                interface: '#f39c12',
                constraint: '#9b59b6'
            };
            return colors[type] || '#95a5a6';
        }
        
        // æ‹–åŠ¨å…ƒç´ 
        let dragElement = null;
        let dragOffset = { x: 0, y: 0 };
        
        function startDrag(e) {
            if (connectionMode) {
                // è¿æ¥æ¨¡å¼
                handleConnectionStart(e);
                return;
            }
            
            dragElement = e.currentTarget;
            const rect = document.getElementById('canvas').getBoundingClientRect();
            const transform = dragElement.getAttribute('transform');
            const match = transform.match(/translate\(([^,]+),([^)]+)\)/);
            
            if (match) {
                dragOffset.x = e.clientX - rect.left - parseFloat(match[1]);
                dragOffset.y = e.clientY - rect.top - parseFloat(match[2]);
            }
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
        }
        
        function drag(e) {
            if (!dragElement) return;
            
            const rect = document.getElementById('canvas').getBoundingClientRect();
            const x = e.clientX - rect.left - dragOffset.x;
            const y = e.clientY - rect.top - dragOffset.y;
            
            dragElement.setAttribute('transform', `translate(${x}, ${y})`);
            
            // æ›´æ–°å…ƒç´ æ•°æ®
            const elementId = dragElement.id;
            const element = elements.find(el => el.id === elementId);
            if (element) {
                element.x = x;
                element.y = y;
                updateConnections();
            }
        }
        
        function stopDrag() {
            dragElement = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
        }
        
        // é€‰æ‹©å…ƒç´ 
        function selectElement(e) {
            if (connectionMode && connectionStart) {
                // å®Œæˆè¿æ¥
                handleConnectionEnd(e);
                return;
            }
            
            // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©
            document.querySelectorAll('.sysml-element').forEach(el => {
                el.classList.remove('selected');
            });
            
            // é€‰æ‹©å½“å‰å…ƒç´ 
            e.currentTarget.classList.add('selected');
            selectedElement = elements.find(el => el.id === e.currentTarget.id);
            
            showProperties(selectedElement);
        }
        
        // æ˜¾ç¤ºå±æ€§
        function showProperties(element) {
            const content = document.getElementById('property-content');
            
            if (!element) {
                content.innerHTML = '<p style="color: #999;">é€‰æ‹©ä¸€ä¸ªå…ƒç´ æŸ¥çœ‹å±æ€§</p>';
                return;
            }
            
            content.innerHTML = `
                <div class="property-group">
                    <label>ID</label>
                    <input type="text" value="${element.id}" readonly>
                </div>
                <div class="property-group">
                    <label>åç§°</label>
                    <input type="text" value="${element.name}" onchange="updateElementName(this.value)">
                </div>
                <div class="property-group">
                    <label>ç±»å‹</label>
                    <input type="text" value="${element.type}" readonly>
                </div>
                ${element.type === 'requirement' ? `
                <div class="property-group">
                    <label>éœ€æ±‚æ–‡æœ¬</label>
                    <textarea onchange="updateElementProperty('text', this.value)">${element.properties.text || ''}</textarea>
                </div>
                <div class="property-group">
                    <label>ä¼˜å…ˆçº§</label>
                    <select onchange="updateElementProperty('priority', this.value)">
                        <option value="LOW">ä½</option>
                        <option value="MEDIUM" selected>ä¸­</option>
                        <option value="HIGH">é«˜</option>
                        <option value="CRITICAL">å…³é”®</option>
                    </select>
                </div>
                ` : ''}
            `;
        }
        
        // æ›´æ–°å…ƒç´ åç§°
        function updateElementName(name) {
            if (!selectedElement) return;
            
            selectedElement.name = name;
            const text = document.querySelector(`#${selectedElement.id} text`);
            if (text) text.textContent = name;
        }
        
        // æ›´æ–°å…ƒç´ å±æ€§
        function updateElementProperty(prop, value) {
            if (!selectedElement) return;
            selectedElement.properties[prop] = value;
        }
        
        // è¿æ¥æ¨¡å¼
        function setConnectionMode(mode) {
            connectionMode = mode;
            connectionStart = null;
            document.getElementById('status').textContent = `è¿æ¥æ¨¡å¼: ${mode}`;
            document.getElementById('canvas').style.cursor = 'crosshair';
        }
        
        function handleConnectionStart(e) {
            connectionStart = e.currentTarget.id;
            document.getElementById('status').textContent = `é€‰æ‹©ç›®æ ‡å…ƒç´ ...`;
        }
        
        function handleConnectionEnd(e) {
            const connectionEnd = e.currentTarget.id;
            
            if (connectionStart && connectionEnd && connectionStart !== connectionEnd) {
                createConnection(connectionStart, connectionEnd, connectionMode);
            }
            
            // é‡ç½®
            connectionMode = null;
            connectionStart = null;
            document.getElementById('canvas').style.cursor = 'default';
            document.getElementById('status').textContent = 'å°±ç»ª';
        }
        
        // åˆ›å»ºè¿æ¥
        function createConnection(startId, endId, type) {
            const connection = {
                id: `connection-${connections.length + 1}`,
                start: startId,
                end: endId,
                type: type
            };
            
            connections.push(connection);
            drawConnection(connection);
            updateStatus();
            
            // ä¿å­˜åˆ°åç«¯
            saveConnectionToBackend(connection);
        }
        
        // ç»˜åˆ¶è¿æ¥
        function drawConnection(connection) {
            const startEl = elements.find(el => el.id === connection.start);
            const endEl = elements.find(el => el.id === connection.end);
            
            if (!startEl || !endEl) return;
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            line.setAttribute('id', connection.id);
            line.setAttribute('class', `connection-line ${connection.type}`);
            
            updateConnectionPath(line, startEl, endEl);
            
            document.getElementById('connections').appendChild(line);
        }
        
        // æ›´æ–°è¿æ¥è·¯å¾„
        function updateConnectionPath(line, startEl, endEl) {
            const x1 = startEl.x + startEl.width / 2;
            const y1 = startEl.y + startEl.height;
            const x2 = endEl.x + endEl.width / 2;
            const y2 = endEl.y;
            
            const path = `M ${x1} ${y1} L ${x2} ${y2}`;
            line.setAttribute('d', path);
        }
        
        // æ›´æ–°æ‰€æœ‰è¿æ¥
        function updateConnections() {
            connections.forEach(conn => {
                const line = document.getElementById(conn.id);
                const startEl = elements.find(el => el.id === conn.start);
                const endEl = elements.find(el => el.id === conn.end);
                
                if (line && startEl && endEl) {
                    updateConnectionPath(line, startEl, endEl);
                }
            });
        }
        
        // æ›´æ–°çŠ¶æ€æ 
        function updateStatus() {
            document.getElementById('element-count').textContent = `å…ƒç´ : ${elements.length}`;
            document.getElementById('connection-count').textContent = `è¿æ¥: ${connections.length}`;
        }
        
        // ä¿å­˜å…ƒç´ åˆ°åç«¯
        async function saveElementToBackend(element) {
            if (element.type === 'requirement') {
                const mutation = `
                    mutation {
                        createRequirement(input: {
                            reqId: "${element.id}"
                            name: "${element.name}"
                            text: "${element.properties.text || ''}"
                            kind: FUNCTIONAL
                            priority: ${element.properties.priority || 'MEDIUM'}
                        }) {
                            ok
                            requirement { id }
                        }
                    }
                `;
                
                try {
                    const response = await fetch('/graphql', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query: mutation })
                    });
                    const data = await response.json();
                    if (data.data.createRequirement.ok) {
                        element.backendId = data.data.createRequirement.requirement.id;
                    }
                } catch (error) {
                    console.error('ä¿å­˜å¤±è´¥:', error);
                }
            }
        }
        
        // ä¿å­˜è¿æ¥åˆ°åç«¯
        async function saveConnectionToBackend(connection) {
            const startEl = elements.find(el => el.id === connection.start);
            const endEl = elements.find(el => el.id === connection.end);
            
            if (startEl?.backendId && endEl?.backendId && connection.type === 'derive') {
                const mutation = `
                    mutation {
                        deriveRequirement(
                            sourceId: "${startEl.backendId}"
                            targetId: "${endEl.backendId}"
                        ) {
                            ok
                        }
                    }
                `;
                
                try {
                    await fetch('/graphql', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query: mutation })
                    });
                } catch (error) {
                    console.error('ä¿å­˜è¿æ¥å¤±è´¥:', error);
                }
            }
        }
        
        // å·¥å…·æ åŠŸèƒ½
        function saveModel() {
            const model = { elements, connections };
            const json = JSON.stringify(model, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sysml-model.json';
            a.click();
        }
        
        function loadModel() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    const model = JSON.parse(event.target.result);
                    elements = model.elements || [];
                    connections = model.connections || [];
                    redrawCanvas();
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        function clearCanvas() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºç”»å¸ƒå—ï¼Ÿ')) {
                elements = [];
                connections = [];
                document.getElementById('elements').innerHTML = '';
                document.getElementById('connections').innerHTML = '';
                updateStatus();
            }
        }
        
        function exportSVG() {
            const svg = document.getElementById('canvas').cloneNode(true);
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sysml-diagram.svg';
            a.click();
        }
        
        function autoLayout() {
            // ç®€å•çš„è‡ªåŠ¨å¸ƒå±€ç®—æ³•
            const cols = Math.ceil(Math.sqrt(elements.length));
            const spacing = 200;
            const startX = 50;
            const startY = 50;
            
            elements.forEach((element, index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                element.x = startX + col * spacing;
                element.y = startY + row * spacing;
            });
            
            redrawCanvas();
        }
        
        function redrawCanvas() {
            document.getElementById('elements').innerHTML = '';
            document.getElementById('connections').innerHTML = '';
            
            elements.forEach(element => drawElement(element));
            connections.forEach(connection => drawConnection(connection));
            updateStatus();
        }
    </script>
</body>
</html>